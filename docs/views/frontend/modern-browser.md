---
title: 近代浏览器原理---从输入URL到页面显示之间的过程
date: 2021-09-28
lastUpdated: 2021-09-28
categories:
  - frontend-article
author: 盐焗乳鸽还要砂锅
tags:
  - 浏览器
---

最近看了关于浏览器的一篇很好的文章，于是想写一个笔记来记录下一些重要的东西。网址在这里噢：https://github.com/75team/w3c/blob/master/articles/20190603_cncuckoo_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8.md

## 架构

Web 浏览器的架构，可以位一个进程包括多个进程，也可以是很多进程包括少数进程通过 IPC 来通信。我们以 Chrome 浏览器的架构为例子，最顶层就是**浏览器进程**，用于协调承担各项工作的其他进程，比如渲染器进程，插件进程，网络进程，CPU 进程等等...
![](https://camo.githubusercontent.com/0a8ad209cf77edb74ae561a73cc28fc1e24157a89c3a97cd4e6b3c06a3652f6f/68747470733a2f2f70302e73736c2e7168696d672e636f6d2f743031623636646639393030623666343661362e706e67)

一个浏览器进程对应着一个标签页。不仅如此，为了实现站点隔离，Chrome 会尽量地给每一个站点分配一个浏览器进程，包括 Iframe。下面介绍一下各个进程的工作吧：

- 浏览器进程：控制浏览器应用的框架，比如历史记录，前进退后刷新、地址栏等，还要处理一些不可见高权限的工作，比如协调网络请求、缓存等等。
- 渲染器进程：负责渲染网页
- 插件进程：负责网站用到的插件
- GPU 进程： 在一个独立进程中处理 CPU 任务。因为 CPU 要处理来自不同应用的请求并且要在同一个页面中渲染，所以放在独立进程里。

_有没有想过为什么 Chrome 需要这么多个进程呢？_

举一个例子，一个浏览器进程对应着一个标签页，若同时打开 3 个标签页，一个标签页崩了，另外两个由于处在不同进程而不会收到影响；若他们都处在一个进程中，则一个标签页卡死另外两个也会被卡住。

多进程架构也有助于隔离和安全。比如通过限制处理用户输入的浏览器进程，来限制用户访问服务器上的一些文件。

这里介绍一下**站点隔离**，即每一个 iframe 分配一个浏览器进程。
假设允许跨站点的 iframe 运行在同一个浏览器进程中，那么就有可能绕过跨域检测，带来一些安全性的问题。但他并不简单，比如在一个网页中使用 Ctrl+f 查找文字，这需要涉及到在不同的进程中查找 (因为有 iframe 的存在)。

## 导航

浏览器进程和其他线程之间的通信，从用户输入 url 开始，浏览器会通过获取互联网上的数据并且将其显示在页面上，这一整个过程叫做**导航**。

1. 首先从处理输入的 url 开始，UI 进程会对输入内容做一个判断，判断是 url 还是一个查询字符串，因为地址栏同时还是一个搜索框。
2. 若是 url，UI 进程会通知网络线程发起网络请求获取网站 html，此时标签页左端显示旋转图标。网络进程进行 DNS 查询，如果是 https 的话还会进行 TLS 连接。若网络线程收到 301，则会告诉 UI 线程，同时重新发送另一个 url 的请求。
3. 读取响应。服务器返回的响应体到来之后，网络进程会检查接收到的前几个字节，比如 Content-Type 头部应该包含数据类型。如果没有，则需要 MIME 类型来嗅探。
4. 联系渲染器进程。网络线程确认浏览器可以导航到目的网页，于是会通知 UI 线程数据准备就绪，然后 UI 线程通知渲染器进程去渲染网页。

> 由于网路请求可能需要时间才能获取相应，浏览器还会应用一个优化策略，在 UI 线程通知网络线程发起请求之后，UI 线程会提前联系启动一个渲染器进程，这样等响应体回来之后，就已经有一个渲染器进程原地待命了。如果发生了重定向，这个待命进程就可能用不上了。

5. 提交导航。数据返回后，浏览器进程和渲染器进程之间通过 IPC 来提交导航。渲染器进程会不间断的接收 HTML 数据流，当浏览器进程收到渲染器进程的确认消息后，导航完成，开始加载文档.... 此时地址栏更新，各种浏览器页面信息更新，历史记录更新，后退/前进按钮起作用......
6. 初始加载完成。提交导航后，渲染器进程开始加载资源和渲染页面。当完成渲染阶段后（所有的 iframe 的`onload`时间触发并执行完成后），渲染器进程会通过 IPC 通知浏览器进程，此时 UI 线程停止标签页的旋转图标。

> 初始加载完成后，浏览器还可能因为 js 进程而加载一些额外的资源并且重新渲染页面。

_若此时用户输入一个新 url 呢？_

浏览器进程会重复以上步骤。但再次之前会确认现在网站是否有`beforeunload`事件。网页一切包括 js 代码都是由渲染器进程负责的，浏览器进程必须与渲染器进程确认后再导航到新站点。

导航到不同网站的时候，会有一个新的独立的渲染器进程来负责新导航，因为旧的渲染器进程需要处理`beforeunload`、`unload`等事件。

若导航请求来自当前渲染器进程，比如`window.location='https://baidu.com'`，这样的话渲染器进程首先处理`beforeunload`、`unload`等事件，然后重复以上步骤。唯一的区别在于导航请求是否由渲染器进程交给浏览器进程。

_Service worker_

在导航阶段还有可能涉及到 Service Worker 的介入，它控制哪些资源可以缓存在本地并使用，何时应该从网络获取新数据。说白了 SW 也是一段 JavaScript 代码，由渲染器进程来进行处理。如果网站注册了 Service Worker，则在导航请求到来之前，UI 线程会让渲染器进程处理 SW 代码，决定是否从网络上获取资源。

若决定发送网路请求，则浏览器进程和渲染器进程之间会有一段延迟（往返通信引起），这时候有一个**导航预加载**的优化：即在 SW 处理的时候同时预先加载资源，再由 SW 决定是否采用网络获取的新资源。

## 渲染

渲染是渲染器进程的内部工作。涉及许许多多的性能的方面...标签页内一切都由渲染器进程来处理。其中主线程负责运行大多数客户端的 JavaScript 代码，少量代码可能会由工作线程负责(SW)。**合成器(compositor)进程和栅格化进程(raster)负责高效平滑地渲染页面**。

渲染器进程的核心任务就是把 HTML、CSS、JavaScript 转换成用户可见可交互的网页。接下来介绍一下渲染器进程工作的一些流程。

- **解析 HTML**

渲染器进程接收到导航提交信息后，开始接收 HTML，其主线程开始解析文本字符串，并将它转换为 DOM 树（Document Object Model）

> HTML 标准要求浏览器兼容错误的 HTML 写法，因此浏览器会忍声吞气绝不报错。

- **加载子资源**

网站一般会用到一些外部资源比如图片啥的。浏览器需要从缓存或者网络中加载这些文件。为了提高效率，Chrome 会在解析 HTML 的同时启动一个*预加载扫描器*。当发现 HTML 字符串中存在外部资源引用时，预加载扫描器会将请求发给网络线程。

![](https://camo.githubusercontent.com/0fec19cea43b13d50ba458c24d978a9507625c1ba38e2a906832b101336594e8/68747470733a2f2f70312e73736c2e7168696d672e636f6d2f743031633931666166396162373233376439622e706e67)

- **JavaScript 可能阻塞解析 HTML**

当 HTML 解析遇到`script`标签时，会暂停解析 HTML 而加载 JavaScript 代码。因为 js 很有可能会改变页面元素样式。等到处理完 js 代码后，再继续解析 HTML。

> 为了解决这个问题更好的加载资源。可以给`script`标签上添加上`defer`或者`async`属性。这样浏览器会异步加载 JavaScript 代码，而不会暂停对 HTML 的解析工作。`defer`和`async`都会让浏览器异步加载 js 代码，但两者的区别是，`defer`会等 HTML 解析工作全部完成之后再开始执行 js 代码；`async`则是等 js 代码加载完成后立即执行 js 代码。

![](https://camo.githubusercontent.com/066b121feedc7cbf695cadd0435491eb26f04cf9dab58df6801985fb8f9b85c6/68747470733a2f2f70302e73736c2e7168696d672e636f6d2f743031663134383136653537646634663866312e706e67)

- **计算样式**

DOM 生成后，还需要计算样式。渲染器进程的主线程开始解析 CSS 并且计算每个 DOM 节点的样式。我们可以在 Chrome 控制台中的`Computed`中看到每个元素计算之后的样式。

![](https://camo.githubusercontent.com/83b1cbb94b0dce6470a714f58a4058eb236e23527a1c2c422a06befc36e522ff/68747470733a2f2f70302e73736c2e7168696d672e636f6d2f743031353730346431343837393438313435352e706e67)

即使网站没有提供 css 样式表，每一个 Dom 节点都有默认的计算样式属性。这是浏览器默认的样式表。

- **布局**

此时，渲染器进程已经知道了文档的结构以及每一个 DOM 元素的样式。但这仍不足以渲染整个页面。比如你的朋友让你画一个红色圆形和蓝色方形，你仍不知道要画成怎样。这个时候，主线程会遍历 DOM 元素及其计算属性，构造出一棵**布局树**。它包含每个节点的坐标和大小信息，但不会包含不可见元素。

> `display:none`的元素则不会包含，但`visibility:hidden`的元素会包含在内

![](https://camo.githubusercontent.com/e6117f9160db0c895cb048b94c7e2d2cbe234343b7778052394e596b40d5a207/68747470733a2f2f70302e73736c2e7168696d672e636f6d2f743031633138623138343030616631363732302e706e67)

- **绘制**

这个时候，浏览器需要知道每一个元素的绘制顺序。比如`z-index`影响元素的叠放。因此在这一步，主线程会遍历布局树并且创建绘制记录，这是用来记录应该先画什么再画什么的。
![](https://camo.githubusercontent.com/6a9cef7d4373cd5e6fdc5863106decf5ebd334192f1e1ad25159774d609ce572/68747470733a2f2f70342e73736c2e7168696d672e636f6d2f743031356663656664383437663063336363322e676966)

渲染是一个流水线作业，先生成 dom，计算样式，生成布局树，再生成绘制记录。这意味着如果一个元素样式变化了，这一个流程就得重新开始。如果元素有动画，浏览器则需要每一帧都运行一次渲染流水线。

即使渲染操作的频率可以跟上显示器刷新率，但由于计算是发生在渲染器进程的主线程上，而主线程很可能因为 JavaScript 代码而阻塞，这导致动画被阻塞。

此时可以使用`requestAnimationFrame()`将涉及动画的 JavaScript 代码操作分块并调度到每一帧的开头执行。

- **合成**

最后应该就到了绘制页面了。我们将上述步骤的信息转换为页面上的像素叫做*栅格化*。

最简单的方式，就是将用户可见页面的部分先转换为像素(栅格化)，然后随着用户滚动页面，再将栅格化的窗口移动，将缺失的部分栅格化。这也是 Chrome 最早的版本的做法。

![](https://camo.githubusercontent.com/6558c414aacc9ed8c7cbc93c54708089f63ef63ddc6766352da1694225cc868f/68747470733a2f2f70332e73736c2e7168696d672e636f6d2f743031333131356233343534353234393663392e676966)

但是现代浏览器会用到更高级的步骤，叫做*合成(composite)*。合成是将页面的不同部分先进行分层并分别栅格化，然后再通过独立的*合成器进程*来合成页面。这样当用户滚动页面的时候，因为所有的网页(层)都已经栅格化了，因此浏览器只需要合成一个新的帧。对于动画也一样：先移动层再生成帧。

那么要怎么分层呢？这里为了确定哪个元素应该在哪一层，主线程会遍历布局树并创建分层树(控制台中性能面板中的*Update Layer Tree*)。如果页面某部分应该独立一层(如划入的菜单)但却没有独立，可以给它加一个`will-change`属性来提醒浏览器。

_以下是根据 MDN 文档的说法_：

> CSS 属性 will-change 为 web 开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。
> 用好这个属性并不是很容易：
>
> - 不要将 will-change 应用到太多元素上：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 will-change 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。
> - 有节制地使用：通常，当元素恢复到初始状态时，浏览器会丢弃掉之前做的优化工作。但是如果直接在样式表中显式声明了 will-change 属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是当元素变化之前和之后通过脚本来切换 will-change 的值。
> - 不要过早应用 will-change 优化：如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。 will-change 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用 will-change 会导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题。
> - 给它足够的工作时间：这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 will-change 属性。

但分层也不是越多越好，合成过多的层可能还不如每一帧都对页面的一小部分进行栅格化来的快。

现在创建好了分层树，有了绘制顺序，主线程会将信息提交给合成器线程。合成器线程会负责将每一层转换为像素-----栅格化。若层太大，则会进行切片，再将每一片交给栅格化线程。栅格化现在将每小片转换为像素后将他们保存在 GPU 内存中。

![](https://camo.githubusercontent.com/037c25408ce5e03baa4c0239ba464dc54f940027a0e0acc8cdb098d7b582d912/68747470733a2f2f70322e73736c2e7168696d672e636f6d2f743031313832616263386432353963626238302e706e67)

> 合成器线程会让栅格化线程优先转换用户视窗周边的小片，而构成一层的小片也会转换为不同分辨率的版本，以防用户缩放的时候用。

在所有小片都栅格化以后，合成器线程会收集一些小片信息，叫做*绘制方块(draw quad)*，用于*合成器帧*。

- 绘制方块：包含小片的内存地址，页面位置等合成页面相关的信息。
- 合成器帧：由多绘制方块拼成的页面中的一帧。

创建好的合成器帧会通过 IPC 交给浏览器进程。与此同时，为了更新浏览器界面，UI 线程还可能会添加另一个合成器帧；或者由于扩展，其他渲染器进程也可能添加额外的合成器帧。所有这些合成器帧都会被发送给 GPU，以便最终显示在屏幕上。如果发送滚动事件，合成器线程会创建新的合成器帧并发给 GPU。
![](https://camo.githubusercontent.com/b700ec268758940f3612f552ba9be6647438328b1baf78e3f5318ca52923a2fe/68747470733a2f2f70302e73736c2e7168696d672e636f6d2f743031363131663161613361313062323566332e706e67)

**使用合成的好处**，是可以不用牵涉主线程。合成器线程不需要等待样式计算或者 JavaScript 代码处理。这就是*只需要合成的动画(http://t.cn/Ai9fO8OW)*被认为是性能最佳的原因。这并不会导致重排或重绘。

## 交互

最后我们来看一下合成器是怎么来处理用户交互的。我们需要知道，在浏览器的角度看，用户的任何输入操作都算是交互：鼠标滚动，触摸屏幕，鼠标悬停等也算。

当用户交互发生的时候(如触摸事件)，浏览器进程首先会接收到这个手势，但也仅止于此，因为标签页内容都是由渲染器进程处理。因此浏览器进程会将事件类型(`touchstart`)以及坐标都发给渲染器进程。渲染器进程会根据事件目标(`target`)来运行注册的监听事件函数。
![](https://camo.githubusercontent.com/3357fc16d1ed30a4a843053e63437eadbae769e2d1b805d6c63f9262db55d373/68747470733a2f2f70302e73736c2e7168696d672e636f6d2f743031333238346465366237343865326137392e706e67)

具体来说，交互事件是由合成器线程来处理的。如前面所说的，如果页面上没有注册事件，那么合成器线程完全独立于主线程来生成新的合成器帧。但页面有了注册事件之后，合成器线程要怎么处理呢？

**非快速滚动区(non-fast scrollable region)**。在页面合成之后，合成器线程会给附加上了事件处理程序的页面区域标记上*non-fast scrollable region*的记号，有了这个记号，合成器线程可以将该区域内发生事件时的事件发送给主线程。

![](https://camo.githubusercontent.com/1bb8ac56e85a5d89f217b3211493f70bd5b2ca919a935bea06bab6afd9c3e338/68747470733a2f2f70312e73736c2e7168696d672e636f6d2f743031626234613631353365383039616639372e706e67)

如果事件发生在非快速滚动区之外，则合成器线程会继续生成合成器帧而不会等待主线程。

这里就不得不提及一下事件委托了。这里我就不展开来说了，只举一个例子。

```js
document.body.addEventListener("touchstart", (evt) => {
  if (evt.target === area) {
    evt.preventDefault();
  }
});
```

这种做法在浏览器看来，会导致整个页面都被标记为*non-fast scrollable region*，这就意味着，即使事件发生在目标以外的区域，合成器线程都会跟主线程沟通，判断是否是目标。这样也就使得合成器线程平滑滚动的优点抵消了。

![](https://camo.githubusercontent.com/1a2f27aca56f45401c469f08b55bb0bbecc1a400b61d35cbef4278f9ae213d95/68747470733a2f2f70332e73736c2e7168696d672e636f6d2f743031356234396662626564393139376133662e706e67)

为了缓冲使用事件委托所带来的副作用，我们可以在注册事件的时候传入`passive:true`。这个属性会提醒浏览器，你仍希望主线程处理事件，但同时合成器线程也可以合成新的合成器帧。

```js
document.body.addEventListener('touchstart', evt => {
  ...
}, { passive: true })
```

> 此外，检查事件是否可以取消也是一个优化策略。假设有一个盒子你想让其内容只能水平滚动。
> 使用`passive:true`可以让页面平滑滚动，但为了限制滚动方向而调用`preventDefault`则不会避免垂直滚动。此时可以检查`evt.cancelable`。
> **Event 实例的只读属性 cancelable 表明该事件是否可以被取消**。

```js
document.body.addEventListener(
  "pointermove",
  (evt) => {
    if (evt.cancelable) {
      evt.preventDefault(); // 阻止原生滚动
      /*
       *  其他操作
       */
    }
  },
  { passive: true }
);
```

或者使用 CSS 如`touch-action`彻底避免使用事件处理程序 (用于设置触摸屏用户如何操纵元素的区域)

```css
#area {
  touch-action: pan-x;
}
```

合成器线程把事件发送给主线程后，要做的第一件事情就是通过命中测试（hit test）找到事件目标。命中测试就是根据渲染器进程生成的绘制记录和坐标找到下方的元素。
![](https://camo.githubusercontent.com/c774f084e231d44d09e7552a90924ddb1c0510bf8cfc34196d69c78fe50d8708/68747470733a2f2f70302e73736c2e7168696d672e636f6d2f743031616363343661623438623038613532312e706e67)

另外，通常的触屏设备每秒产生 60~120 次触碰事件，鼠标每秒则会产生约 100 次。即，输入事件具有比刷新率 60 的屏幕有更高的保真度。这会导致过多的命中测试以及 JavaScript 执行。
![](https://camo.githubusercontent.com/22891de8c40076a1ccdd57226aea112c3bf94c238da6cda723ebd1bd3b938805/68747470733a2f2f70322e73736c2e7168696d672e636f6d2f743031346532373135356664623331396233652e706e67)

为了把对主线程过多的调用降至最低，Chrome 会合并连续触发的事件(`wheel`、`touchmove`)并将它们延时到在下一次`requestAnimationFrame`之前派发。

> `window.requestAnimationFrame()` 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。

对于非连续触发事件，则会立即派发。

在一些特殊应用场景下，比如需要基于`touchmove`事件的坐标生成轨迹的绘图应用，这种合并操作就会导致丢失一些坐标，影响平滑度。

![](https://camo.githubusercontent.com/4dee811a1b54030530af599219dcac00285b9850aa5e2e4203633de9f7f95990/68747470733a2f2f70302e73736c2e7168696d672e636f6d2f743031666334633934663333376239666135322e706e67)

此时可以利用指针事件的`getCoalescedEvents()`方法取得被合并事件的信息。

```js
window.addEventListener("pointermove", (event) => {
  const events = event.getCoalescedEvents();
  for (let event of events) {
    const x = event.pageX;
    const y = event.pageY;
    // 使用x和y坐标画线
  }
});
```
